package jp.co.soramitsu.schema.codegen

import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import jp.co.soramitsu.schema.StringType
import jp.co.soramitsu.schema.TypePreset
import jp.co.soramitsu.schema.definitions.types.Type
import jp.co.soramitsu.schema.definitions.types.composite.*
import jp.co.soramitsu.schema.definitions.types.primitives.*
import java.nio.file.Paths
import java.util.*


object CodeGenerator {

    fun generate(typePreset: TypePreset) {
        typePreset.map { (_, typeRef) ->
            when (val type = typeRef.value) {
                is Struct -> generateRegularStruct(type)
                is EnumType -> generateEnum(type)
                is TupleStruct -> generateTupleStruct(type)
                else -> null
            }
        }
            .filterNotNull()
            .map { it.addComment("Do not change. Autogenerated code") }
            .map(FileSpec.Builder::build)
            .forEach { it.writeTo(Paths.get("codegen-engine/src/main/kotlin")) }
    }

    private fun generateClassSkeleton(className: String): TypeSpec.Builder {
        val clazz = TypeSpec.classBuilder(className)

            .addModifiers(KModifier.PUBLIC)

        return clazz
    }

    private fun generateRegularStruct(type: Struct): FileSpec.Builder? {
        val (className, packageName, _) = defineFullClassNames(type.name)

        val clazz = generateClassSkeleton(className)
            .addKdoc("$className\n\n")
            .addKdoc("Generated from '${type.name}' regular structure")

        implementScaleCodec(
            clazz,
            className,
            packageName,
            implScaleReaderForStructs(type, className),
            implScaleWriterForStructs(type)
        )

        val constructorBuilder = FunSpec.constructorBuilder()

        for ((name, typeRef) in type.mapping) {
            val normalizedName = convertToCamelCase(name)
            val kotlinType = resolveKotlinType(typeRef.value!!)

            constructorBuilder.addParameter(
                ParameterSpec.builder(normalizedName, kotlinType)
                    .build()
            )

            clazz.addProperty(
                PropertySpec.builder(normalizedName, kotlinType, KModifier.PRIVATE)
                    .initializer(normalizedName)
                    .build()
            )
        }

        if (constructorBuilder.parameters.isNotEmpty()) {
            clazz.primaryConstructor(constructorBuilder.build())
        }

        return FileSpec.builder("jp.co.soramitsu.schema.generated.$packageName", className)
            .addType(clazz.build())
    }

    private fun implScaleWriterForStructs(type: Struct): CodeBlock {
        val code = StringJoiner("\n")
        for ((propertyName, typeRef) in type.mapping) {
            code.add(resolveWriteImplementation(typeRef.value!!, convertToCamelCase(propertyName)))
        }
        return CodeBlock.of("$code")
    }

    private fun resolveReadImplementation(type: Type<*>): String {
        return when (type) {
            is StringType -> "reader.readString()"
            is BooleanType -> "reader.readBoolean()"
            is Option -> {
                val className = when (val kotlinType = resolveKotlinType(type.innerType!!)) {
                    is ClassName -> kotlinType.canonicalName
                    is ParameterizedTypeName -> kotlinType.rawType.canonicalName
                    else -> throw RuntimeException("Unexpected type")
                }
                "reader.readOptional($className)"
            }
            is Compact -> "reader.readCompactInt()"
            is UIntType -> "reader.readLong().toInt()"
            is FixedByteArray, is DynamicByteArray -> "reader.readByteArray()"
            is Vec -> {
                when (type.innerType) {
                    is Tuple -> {
                        val tuple = type.innerType as Tuple
                        val keyClassName = when (val kotlinType = resolveKotlinType(tuple.typeReferences.first().value!!)) {
                            is ClassName -> kotlinType.canonicalName
                            is ParameterizedTypeName -> kotlinType.rawType.canonicalName
                            else -> throw RuntimeException("Unexpected type")
                        }
                        val valueClassName = when (val kotlinType = resolveKotlinType(tuple.typeReferences.last().value!!)) {
                            is ClassName -> kotlinType.canonicalName
                            is ParameterizedTypeName -> kotlinType.rawType.canonicalName
                            else -> throw RuntimeException("Unexpected type")
                        }
                        "reader.read(jp.co.soramitsu.schema.codegen.MapReader($keyClassName, $valueClassName))"
                    }
                    else -> {
                        when (val kotlinType = resolveKotlinType(type.innerType!!)) {
                            is ClassName -> "reader.read(io.emeraldpay.polkaj.scale.reader.ListReader(${kotlinType.simpleName}))"
                            is ParameterizedTypeName -> "reader.read(io.emeraldpay.polkaj.scale.reader.ListReader(${kotlinType.rawType.simpleName}))"
                            else -> throw RuntimeException("Unexpected type")
                        }
                    }
                }
            }
            is SetType -> {
                when (val kotlinType = resolveKotlinType(type.innerType!!)) {
                    is ClassName -> "reader.read(io.emeraldpay.polkaj.scale.reader.ListReader(${kotlinType.simpleName})).toSet()"
                    is ParameterizedTypeName -> "reader.read(io.emeraldpay.polkaj.scale.reader.ListReader(${kotlinType.rawType.simpleName})).toSet()"
                    else -> throw RuntimeException("Unexpected type")
                }
            }
            else -> {
                when (val kotlinType = resolveKotlinType(type)) {
                    is ClassName -> "${kotlinType.canonicalName}.read(reader)"
                    is ParameterizedTypeName -> "${kotlinType.rawType.canonicalName}.read(reader)"
                    else -> throw RuntimeException("Unexpected type")
                }
            }
        }
    }

    private fun resolveWriteImplementation(type: Type<*>, propertyName: String): String {
        return when (type) {
            is StringType -> "writer.writeString(instance.`$propertyName`)"
            is BooleanType -> "writer.writeByte(if (instance.$propertyName) {1} else {0})\n"
            is Option -> {
                val className = when (val kotlinType = resolveKotlinType(type.innerType!!)) {
                    is ClassName -> kotlinType.canonicalName
                    is ParameterizedTypeName -> kotlinType.rawType.canonicalName
                    else -> throw RuntimeException("Unexpected type")
                }
                "writer.writeOptional($className, instance.`$propertyName`)"
            }
            is Compact -> "writer.writeCompact(instance.`$propertyName`)"
            is UIntType -> "writer.writeLong(instance.`$propertyName`.toLong())"
            is FixedByteArray, is DynamicByteArray -> "writer.writeByteArray(instance.`$propertyName`)"
            is Vec -> {
                when (type.innerType) {
                    is Tuple -> {
                        val tuple = type.innerType as Tuple
                        val keyClassName = when (val kotlinType = resolveKotlinType(tuple.typeReferences.first().value!!)) {
                            is ClassName -> kotlinType.canonicalName
                            is ParameterizedTypeName -> kotlinType.rawType.canonicalName
                            else -> throw RuntimeException("Unexpected type")
                        }
                        val valueClassName = when (val kotlinType = resolveKotlinType(tuple.typeReferences.last().value!!)) {
                            is ClassName -> kotlinType.canonicalName
                            is ParameterizedTypeName -> kotlinType.rawType.canonicalName
                            else -> throw RuntimeException("Unexpected type")
                        }
                        "writer.write(jp.co.soramitsu.schema.codegen.MapWriter($keyClassName, $valueClassName), instance.`$propertyName`)"
                    }
                    else -> {
                        when (val kotlinType = resolveKotlinType(type.innerType!!)) {
                            is ClassName -> "writer.write(io.emeraldpay.polkaj.scale.writer.ListWriter(${kotlinType.simpleName}), instance.`$propertyName`)"
                            is ParameterizedTypeName -> "writer.write(io.emeraldpay.polkaj.scale.writer.ListWriter(${kotlinType.rawType.simpleName}), instance.`$propertyName`)"
                            else -> throw RuntimeException("Unexpected type")
                        }
                    }
                }
            }
            is SetType -> {
                when (val kotlinType = resolveKotlinType(type.innerType!!)) {
                    is ClassName -> "writer.write(io.emeraldpay.polkaj.scale.writer.ListWriter(${kotlinType.simpleName}), instance.`$propertyName`.toList())"
                    is ParameterizedTypeName -> "writer.write(io.emeraldpay.polkaj.scale.writer.ListWriter(${kotlinType.rawType.simpleName}), instance.${propertyName.toList()}()))"
                    else -> throw RuntimeException("Unexpected type")
                }
            }
            else -> {
                when (val kotlinType = resolveKotlinType(type)) {
                    is ClassName -> "${kotlinType.canonicalName}.write(writer, instance.`$propertyName`)"
                    is ParameterizedTypeName -> "${kotlinType.rawType.canonicalName}.write(writer, instance.`$propertyName`)"
                    else -> throw RuntimeException("Unexpected type")
                }
            }
        }
    }

    private fun implScaleReaderForStructs(type: Struct, structName: String): CodeBlock {
        val code = StringJoiner(", ")
        for ((_, typeRef) in type.mapping) {
            code.add(resolveReadImplementation(typeRef.value!!))
        }
        return CodeBlock.of("return $structName($code)")
    }

    private fun implScaleWriterForTupleStructs(type: TupleStruct): CodeBlock {
        val code = StringJoiner("\n")
        for (typeRef in type.types) {
            val propertyName = createTupleStructName(typeRef.value!!)
            code.add(resolveWriteImplementation(typeRef.value!!, convertToCamelCase(propertyName)))
        }
        return CodeBlock.of("$code")
    }

    private fun implScaleReaderForTupleStructs(type: TupleStruct, structName: String): CodeBlock {
        val code = StringJoiner(", ")
        for (typeRef in type.types) {
            code.add(resolveReadImplementation(typeRef.value!!))
        }
        return CodeBlock.of("return $structName($code)")
    }

    private fun implScaleReaderForEnumVariant(
        variant: EnumType.Variant,
        canonicalName: String
    ): CodeBlock {
        val code = CodeBlock.of(resolveReadImplementation(variant.type!!.value!!))
        return CodeBlock.of("return ${canonicalName}($code)")
    }

    private fun implScaleWriterForEnumVariant(
        variant: EnumType.Variant,
        propertyName: String,
    ): CodeBlock {
        val code = CodeBlock.of(resolveWriteImplementation(variant.type!!.value!!, propertyName))
        return CodeBlock.builder()
            .add("$code")
            .build()
    }

    private fun generateTupleStruct(type: TupleStruct): FileSpec.Builder? {
        val (className, packageName, _) = defineFullClassNames(type.name)

        val clazz = generateClassSkeleton(className)
            .addKdoc("$className\n\n")
            .addKdoc("Generated from '${type.name}' tuple structure")

        implementScaleCodec(
            clazz,
            className,
            packageName,
            implScaleReaderForTupleStructs(type, className),
            implScaleWriterForTupleStructs(type)
        )

        val constructorBuilder = FunSpec.constructorBuilder()

        for (typeRef in type.types) {
            val normalizedName = createTupleStructName(typeRef.value!!)

            val kotlinType = resolveKotlinType(typeRef.value!!)

            constructorBuilder.addParameter(
                ParameterSpec.builder(normalizedName, kotlinType)
                    .build()
            )

            clazz.addProperty(
                PropertySpec.builder(normalizedName, kotlinType, KModifier.PRIVATE)
                    .initializer(normalizedName)
                    .build()
            )
        }

        if (constructorBuilder.parameters.isNotEmpty()) {
            clazz.primaryConstructor(constructorBuilder.build())
        }

        return FileSpec.builder("jp.co.soramitsu.schema.generated.$packageName", className)
            .addType(clazz.build())
    }

    private fun createTupleStructName(type: Type<*>): String {
        return when (type) {
            is FixedByteArray -> {
                "array"
            }
            else -> {
                val (propertyName, _) = defineFullClassNames(type.name)
                propertyName.decapitalize(Locale.getDefault())
            }
        }
    }

    private fun generateEnum(type: EnumType): FileSpec.Builder? {
        val (className, packageName, _) = defineFullClassNames(type.name)

        val clazz = generateClassSkeleton(className)
            .addModifiers(KModifier.SEALED)
            .addKdoc("$className\n\n")
            .addKdoc("Generated from '${type.name}' enum")
            .addFunction(
                FunSpec.builder("discriminant")
                    .addModifiers(KModifier.ABSTRACT)
                    .returns(Int::class.java, CodeBlock.of("Discriminator of variant in enum"))
                    .build()
            )

        for (variant in type.variants) {

            val variantClass = TypeSpec.classBuilder(variant.name)
                .superclass(ClassName("jp.co.soramitsu.schema.generated.$packageName", className))
                .addFunction(
                    FunSpec.builder("discriminant")
                        .addModifiers(KModifier.OVERRIDE)
                        .returns(Int::class.java)
                        .addCode("return %L", variant.discriminant)
                        .build()
                )
                .addKdoc("'${variant.name}' variant")


            if (variant.type != null) {
                val (variantPropertyName, _, _) = defineFullClassNames(variant.name)
                val normalizedName = convertToCamelCase(variantPropertyName)
                    .decapitalize(Locale.getDefault())
                val kotlinType = resolveKotlinType(variant.type.value!!)
                val constructorBuilder = FunSpec.constructorBuilder()
                    .addParameter(
                        ParameterSpec.builder(normalizedName, kotlinType)
                            .build()
                    )

                variantClass.addProperty(
                    PropertySpec.builder(normalizedName, kotlinType, KModifier.PRIVATE)
                        .initializer(normalizedName)
                        .build()
                )

                variantClass.primaryConstructor(constructorBuilder.build())
                implementScaleCodec(
                    variantClass,
                    variant.name,
                    "$packageName.$className",
                    implScaleReaderForEnumVariant(variant, "jp.co.soramitsu.schema.generated.$packageName.$className.${variant.name}"),
                    implScaleWriterForEnumVariant(variant, normalizedName)
                )
            } else {
                implementScaleCodec(
                    variantClass,
                    variant.name,
                    "$packageName.$className",
                    CodeBlock.of("return jp.co.soramitsu.schema.generated.$packageName.$className.${variant.name}()"),
                    CodeBlock.of("//nothing to write, enum variant do not have properties")
                )
            }
            clazz.addType(variantClass.build())
        }

        implementScaleCodec(
            clazz,
            className,
            packageName,
            implScaleReaderForEnum(type.variants),
            implScaleWriterForEnum(type.variants)
        )
            return FileSpec.builder("jp.co.soramitsu.schema.generated.$packageName", className)
            .addType(clazz.build())
    }

    private fun implScaleReaderForEnum(variants: List<EnumType.Variant>): CodeBlock {
        val rawCode = StringJoiner("\n")
        rawCode.add("return when(reader.readUByte()) {")
        for ((name, discriminant, _) in variants) {
            rawCode.add("\t$discriminant -> $name.read(reader)")
        }
        rawCode.add("\telse -> throw RuntimeException(\"Unresolved discriminant of the enum variant\")")
        return CodeBlock.of(rawCode.add("}").toString())
    }

    private fun implScaleWriterForEnum(variants: List<EnumType.Variant>) : CodeBlock {
        val rawCode = StringJoiner("\n")
        rawCode.add("writer.directWrite(instance.discriminant())")
        rawCode.add("when(instance.discriminant()) {")
        for ((name, discriminant, _) in variants) {
            rawCode.add("\t$discriminant -> $name.write(writer, instance as $name)")
        }
        rawCode.add("\telse -> throw RuntimeException(\"Unresolved discriminant of the enum variant\")")
        return CodeBlock.of(rawCode.add("}").toString())
    }

    private fun defineFullClassNames(typeFullName: String): ClassBlueprint {
        //expected only one wildcard at most
        val wildcard = typeFullName.substringAfter('<', "")
            .substringBeforeLast('>', "")
        val className = typeFullName.substringBefore('<')
            .substringAfterLast("::")
        val packageName = typeFullName.substringBeforeLast(className)
            .removeSuffix("::")
            .removePrefix("iroha")
            .replace("::", ".")
            .replace("_", "")
        return ClassBlueprint(className, packageName, wildcard)
    }

    private data class ClassBlueprint(val className: String, val packageName: String, val wildcard: String)

    private fun convertToCamelCase(target: String): String {
        val tokenizer = StringTokenizer(target, "_")
        return if (tokenizer.hasMoreTokens()) {
            val resultBuilder = StringBuilder(tokenizer.nextToken())
            for (token in tokenizer) {
                resultBuilder.append((token as String).capitalize(Locale.getDefault()))
            }
            resultBuilder.toString()
        } else {
            target
        }
    }

    private fun resolveKotlinType(type: Type<*>): TypeName {
        return when (type) {
            is StringType -> ClassName("kotlin", "String")
            is BooleanType -> ClassName("kotlin", "Boolean")
            is EnumType, is TupleStruct, is Struct -> {
                val (className, packageName, _) = defineFullClassNames(type.name)
                ClassName("jp.co.soramitsu.schema.generated.$packageName", className)
            }
            is Vec -> {
                when (type.innerType) {
                    is Tuple -> {
                        val tuple = type.innerType as Tuple
                        ClassName("kotlin.collections", "Map")
                            .parameterizedBy(resolveKotlinType(tuple.typeReferences.first().value!!), resolveKotlinType(tuple.typeReferences.last().value!!))
                    }
                    else -> {
                        ClassName("kotlin.collections", "List")
                            .parameterizedBy(resolveKotlinType(type.innerType!!))
                    }
                }
            }
            is SetType -> {
                ClassName("kotlin.collections", "Set")
                    .parameterizedBy(resolveKotlinType(type.innerType!!))
            }
            is Option -> {
                ClassName("java.util", "Optional")
                    .parameterizedBy(resolveKotlinType(type.innerType!!))
            }
            is Compact -> ClassName("kotlin", "Int")
            is UIntType -> ClassName("kotlin", "Int")
            is Tuple -> {
                ClassName("kotlin", "Pair")
                    .parameterizedBy(ClassName("kotlin", "String"), ClassName("kotlin", "String"))
            }
            is FixedByteArray, is DynamicByteArray -> {
                ClassName("kotlin", "ByteArray")
            }
            else -> throw RuntimeException("unexpected type: $type")
        }
    }

    private fun implementScaleCodec(
        clazz: TypeSpec.Builder,
        className: String,
        packageName: String,
        readerCode: CodeBlock,
        writerCode: CodeBlock,
    ) {
        clazz.addType(
            TypeSpec.companionObjectBuilder()
                .addSuperinterface(
                    ClassName("io.emeraldpay.polkaj.scale", "ScaleReader")
                        .parameterizedBy(
                            ClassName(
                                "jp.co.soramitsu.schema.generated.$packageName",
                                className
                            )
                        )
                )
                .addSuperinterface(
                    ClassName("io.emeraldpay.polkaj.scale", "ScaleWriter")
                        .parameterizedBy(
                            ClassName(
                                "jp.co.soramitsu.schema.generated.$packageName",
                                className
                            )
                        )
                )
                .addFunction(
                    FunSpec.builder("read")
                        .addParameter(
                            ParameterSpec
                                .builder(
                                    "reader",
                                    ClassName("io.emeraldpay.polkaj.scale", "ScaleCodecReader")
                                )
                                .build()
                        )
                        .addCode(readerCode)
                        .addModifiers(KModifier.OVERRIDE)
                        .returns(
                            ClassName(
                                "jp.co.soramitsu.schema.generated.$packageName",
                                className
                            )
                        )
                        .build()
                )
                .addFunction(
                    FunSpec.builder("write")
                        .addParameter(
                            ParameterSpec
                                .builder(
                                    "writer",
                                    ClassName("io.emeraldpay.polkaj.scale", "ScaleCodecWriter")
                                )
                                .build()
                        )
                        .addParameter(
                            ParameterSpec
                                .builder(
                                    "instance",
                                    ClassName(
                                        "jp.co.soramitsu.schema.generated.$packageName",
                                        className
                                    )
                                )
                                .build()
                        )
                        .addCode(writerCode)
                        .addModifiers(KModifier.OVERRIDE)
                        .build()
                )
                .build()
        )
    }
}
